# Dynamic Data Structure Solutions

## Project Overview

The Dynamic Data Structure Solutions project focuses on developing efficient algorithms and data structures to solve complex problems in the domain of data structures and algorithms. The project is divided into two phases, each addressing specific aspects of data structure operations.

## Phase 1: Linear ADT

In this phase, I implemented a subclass called `SList2`, which extends the `SList` class representing a singly linked list. The `SList2` class includes methods for performing various operations on the linked list, such as deleting the largest sequence of equal numbers, fixing loops, and performing left and right shifts. I ensured robustness, correctness, and efficiency of the implementations while adhering to strict guidelines and restrictions on the use of Python structures.

## Phase 2: Binary Search Tree Operations

The second phase involved the implementation of a subclass named `BST2`, extending the `BinarySearchTree` class representing a binary search tree. This subclass includes methods for finding nodes at a specific distance from a given node and creating new binary search trees based on merge, intersection, or difference operations. I prioritized efficiency, correctness, and adherence to project requirements, considering factors such as time and space complexity.

## Collaboration and Delivery

The Dynamic Data Structure Solutions project was developed by me. I worked diligently to design and implement effective solutions to the given problem statements. I ensured open communication and collaboration with my lab partner to exchange ideas and discuss design decisions. The project was successfully defended in an oral examination, showcasing my comprehensive understanding and ability to articulate the technical aspects of the work.

## How to Run the Project

To run the project, follow these steps:

1. Ensure you have Python installed on your system.
2. Download the project files provided, including the code files for each phase and the unit tests.
3. Open the code files and examine the implementations and function definitions.
4. Run the unit tests to validate the correctness of the implemented functionalities.
5. Experiment with the code by modifying inputs or adding your own test cases.
6. If necessary, refer to the project documentation for any specific instructions or additional details.
